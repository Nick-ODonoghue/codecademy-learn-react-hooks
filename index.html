<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Learn React: Hooks - Codecademy | NickOD.xyz</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="reset.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <main class="wrapper">

    <h1>Codecademy - Learn React: Hooks</h1>
    <p>Notes taken while going through the <a href="https://www.codecademy.com/learn/learn-react-hooks">Codecademy Learn
        React: Hooks
        course</a>
    </p>

    <h2>The State Hook</h2>

    <section>
      <h3>Why Use Hooks</h3>
      <ul>
        <li>React Hooks are functions that allow us to manage state and handle side effects in function components.</li>
        <li>They provide a way to add state and lifecycle functionalities to function components, making them more
          powerful and flexible.</li>
        <li>Using Hooks, we can manage the internal state of components directly within the function body.</li>
        <li>Hooks allow us to declare how our user interface should look based on the state.</li>
        <li>Some of the built-in Hooks provided by React include useState(), useEffect(), useContext(), useReducer(),
          and useRef().</li>
        <li>useState() allows us to add and manage state in function components.</li>
        <li>useEffect() enables us to handle side effects, such as fetching data or subscribing to events, after the
          component has rendered.</li>
        <li>useContext() allows us to access and use context within a function component.</li>
        <li>useReducer() provides a way to manage state using a reducer function similar to how it's done in Redux.</li>
        <li>useRef() gives us a mutable ref object that persists across re-renders and allows us to access and modify
          DOM elements or other values.</li>
        <li>By using Hooks, we can write cleaner and more concise code and take advantage of the benefits of function
          components while still having access to state and side effects.</li>
      </ul>
    </section>

    <section>
      <h3>Update Function Component State</h3>
      <ul>
        <li>The State Hook is commonly used for building React components.</li>
        <img src="./assets/images/importUseState.jpg" alt="import useState">
        <li>To use the State Hook, we import it from the React library using object destructuring.</li>
        <li>When useState() is called, it returns an array with two values: the current state and a state setter
          function.</li>
        <li>The current state represents the current value of the state, while the state setter function is used to
          update the state's value.</li>
        <img src="assets/images/destructuringUseState.jpg" alt="destructuring useState">
        <li>We can track the current state and modify it by assigning the array values to local variables using array
          destructuring.</li>
        <li>In a function component, we can use the State Hook to manage state.</li>
        <img src="assets/images/stateHookManagement.jpg" alt="state hook management">
        <li>The example component "Toggle" demonstrates the usage of the State Hook.</li>
        <li>The state setter function, setToggle(), is called by onClick event listeners to update the value of the
          state.</li>
        <li>By calling the state setter function with the next state value as an argument, we can update the state and
          trigger a re-render of the component.</li>
        <li>useState() allows React to keep track of the current state value from one render to the next.</li>
      </ul>
    </section>

    <section>
      <h3>Initialize State</h3>
      <ul>
        <li>The State Hook in React allows us to manage the value of any primitive data type or data collections like
          arrays and objects.</li>
        <li>We can initialize state by calling the useState() function and passing the initial value as an argument.
        </li>
        <img src="./assets/images/useState.jpg" alt="useState">
        <li>The ToggleLoading() function component in the example uses a boolean data type for the state variable
          "isLoading" to represent whether data is loading or not.</li>
        <li>The state setter function, setIsLoading(), is used to update the value of the state variable.</li>
        <img src="./assets/images/useStateInitializer.jpg" alt="useState initializer">
        <li>To start the component with isLoading set to true, we can pass the initial value as true: const [isLoading,
          setIsLoading] = useState(true);</li>
        <li>The useState() function has three effects on the component</li>
        <li>During the first render, the initial state argument is used.</li>
        <li>When the state setter is called, React ignores the initial state argument and uses the new value.</li>
        <li>When the component re-renders for any other reason, React continues to use the same value from the previous
          render.</li>
        <li>If we don't pass an initial value to useState(), the current value of the state during the first render will
          be undefined. It's preferable to explicitly initialize the state, and if the value is not available during the
          first render, we can pass null instead of leaving it undefined.</li>
      </ul>
    </section>

    <section>
      <h3>Use State Setter Outside of JSX</h3>
      <ul>
        <li>We can use the State Hook to manage the changing value of a string in a text input field.</li>
        <img src="./assets/images/stateSetter.jpg" alt="state setter">
        <li>We use array destructuring to create a local state variable (e.g., email) and a local setter function (e.g.,
          setEmail) using the useState() function.</li>
        <li>The email variable holds the current state value, and the setEmail function is used to update the value.
        </li>
        <li>We define an event handler function (e.g., handleChange) that is called when the onChange event is triggered
          on the input field.</li>
        <li>The event handler updates the value of email by calling the setEmail function with the new value obtained
          from the event.</li>
        <li>In JSX, we bind the value of the input field to the email state variable, and we set the onChange event
          listener to the handleChange function.</li>
        <li>It's a good practice to separate the logic of event handlers from JSX to improve readability, testability,
          and maintainability.</li>
        <img src="./assets/images/stateSetterLarge.jpg" alt="state setter large">
        <li>We can simplify the event handler by directly passing the value from the event (e.g., event.target.value) to
          the setEmail function.</li>
        <img src="./assets/images/stateSetterMedium.jpg" alt="state setter medium">
        <li>Object restructuring can be used to extract the target property from the event parameter, further
          simplifying the code.</li>
        <img src="./assets/images/stateSetterConcise.jpg" alt="state setter concise">
        <li>All the variations of the event handler code snippets behave the same way, and the choice depends on
          personal preference and code style.</li>
      </ul>
    </section>

    <section>
      <h3>Set From Previous State</h3>
      <ul>
        <li>React state updates are asynchronous, which means there can be scenarios where portions of your code run
          before the state finishes updating.</li>
        <li>To ensure that you are working with the most up-to-date state value, it is recommended to update state using
          a callback function.</li>
        <img src="./assets/images/setStateCallbackFunction.jpg" alt="state setter callback function">
        <li>The callback function is passed as an argument to the state setter function (e.g., setCount) instead of
          passing a new value directly.</li>
        <li>By using the callback function approach, you can access the previous state value and compute the next state
          based on it.</li>
        <li>In the example code, the increment event handler is called when a button is clicked. Inside this function,
          the state is updated using setCount with a callback function.</li>
        <li>The callback function takes the previous count value as an argument (prevCount), and the value returned from
          the callback is used as the next state value.</li>
        <li>By using the callback function (prevCount => prevCount + 1), we increment the count value by 1 based on the
          previous count value.</li>
        <li>While it would work in this example to directly call setCount(count + 1), using the callback approach is
          considered safer in certain scenarios.</li>
      </ul>
    </section>

    <section>
      <h3>Arrays in State</h3>
      <ul>
        <li>JavaScript arrays are a suitable data model for managing and rendering lists of JSX elements.</li>
        <img src="./assets/images/arraysInState.jpg" alt="arrays in state">
        <li>In the given example, there are two arrays:</li>
        <li>The options array contains the names of pizza toppings available. It is defined outside the component as
          static data.</li>
        <li>The selected array represents the currently selected toppings for a personal pizza. It is managed within the
          component's state using the useState hook.</li>
        <li>The options array remains static and does not change. It is defined outside the function component to
          prevent unnecessary re-creation on each component re-render.</li>
        <li>The .map() method is used on the options array to render a button for each topping in the JSX.</li>
        <li>The selected array is initialized as an empty array in the component's state.</li>
        <li>When a button is clicked, the toggleTopping() event handler is called. It retrieves the clicked topping from
          the event object.</li>
        <li>When updating an array in state, it is important to replace the previous array with a new array rather than
          adding new data to the existing array.</li>
        <li>The spread syntax (...prev) is used to create a new array that includes all the elements from the previous
          array. This ensures that any information from the previous array is retained in the new array when updating
          the state.</li>
        <li>The toggleTopping() function checks if the clicked topping is already selected. If it is, the topping is
          filtered out of the state array. If it is not selected, the topping is added to the state array using the
          spread syntax along with the previous elements.</li>
        <li>The JSX renders a button for each topping, with the button label changing based on whether the topping is
          selected or not.</li>
        <li>The selected toppings are displayed in a 'p' element using the selected.join(', ') method to format the
          array as a comma-separated string.</li>
      </ul>
    </section>

    <section>
      <h3>Objects in State</h3>
      <ul>
        <li>State can also be used with objects in React.</li>
        <li>Grouping related variables into an object can be helpful.</li>
        <img src="./assets/images/objectsInState.jpg" alt="objects in state">
        <li>Use the useState hook to initialize the state object (formState) with an empty object {}.</li>
        <li>Create an event handler function (handleChange) to update the state based on user input.</li>
        <li>Destructure the name and value properties from the target object within the event handler.</li>
        <li>Update the state using the state setter function with a callback: setFormState((prev) => ({ ...prev, [name]:
          value })).</li>
        <li>The spread syntax (...prev) copies the previous state object and then updates the specific key-value pair
          with [name]: value.</li>
        <li>Reuse the event handler for multiple input fields by using the name attribute of the input tag to identify
          the input triggering the change event.</li>
        <li>When the input values are updated, the handleChange function is called.</li>
        <li>Wrap the new state object in parentheses when using the state setter callback: setFormState((prev) => ({
          ...prev })).</li>
        <li>The square brackets around name enable using the string value stored in the name variable as a property key.
        </li>
      </ul>
    </section>

    <section>
      <h3>Seperate Hooks for Seperate States</h3>
      <ul>
        <li>While it can be helpful to store related data in a data collection (like an array or object), it's also
          beneficial to create separate state variables for data that change independently.</li>
        <img src="./assets/images/singleObjectState.jpg" alt="single state object">
        <li>Managing dynamic data becomes easier when keeping the data models as simple as possible.</li>
        <li>Unlike this:</li>
        <img src="./assets/images/singleObjectStateUpdate.jpg" alt="single object state update">
        <li>Instead of using a single object to hold all related state, create multiple state variables based on the
          values that tend to change together.</li>
        <li>Separate state variables make the code simpler, easier to read, test, and reuse across components.</li>
        <img src="./assets/images/multipleStates.jpg" alt="multiple states">
        <li>Rewriting the example: Create individual state variables for currentGrade, classmates, classDetails, and
          exams.</li>
        <li>Each state variable can have its own state setter function, making it straightforward to update specific
          values without the need for complex code.</li>
        <li>Organizing data in separate state variables allows for more flexibility in managing and organizing dynamic
          data within components.</li>
        <li>Hooks provide the freedom to choose the most suitable data organization approach based on the specific needs
          of the application.</li>
      </ul>
    </section>

    <section>
      <h3>Review: State Hooks</h3>
      <ul>
        <li>With React, we feed static and dynamic data models to JSX to render a view to the screen.</li>
        <li>Hooks are used to “hook into” the internal component state for managing dynamic data in function components.
        </li>
        <li>We employ the State Hook using the code below. The currentState references the current value of the state
          and initialState initializes the value of the state for the component’s first render.</li>
        <img src="./assets/images/stateHook.jpg" alt="state hook">
        <li>State setters can be called in event handlers.</li>
        <li>We can define simple event handlers inline in our JSX and complex event handlers outside of our JSX.</li>
        <li>We use a state setter callback function when our next value depends on our previous value.</li>
        <li>We use arrays and objects to organize and manage related data that tend to change together.</li>
        <li>Use the spread syntax on collections of dynamic data to copy the previous state into the next state like so:
          setArrayState((prev) => [ ...prev ]) and setObjectState((prev) => ({ ...prev })).</li>
        <li>It’s best practice to have multiple, simpler states instead of having one complex state object.</li>
      </ul>
    </section>

    <h2>The Fetch Hook</h2>

    <section>
      <h3>Function Component Effects</h3>
      <ul>
        <li>The Effect Hook (useEffect()) allows us to perform actions every time a component is rendered or
          re-rendered.</li>
        <li>By combining the Effect Hook with states, we can create dynamic changes in our web pages.</li>
        <img src="./assets/images/importEffectHook.jpg" alt="importing useEffect">
        <li>To use the Effect Hook, import it from the 'react' library: import { useEffect } from 'react';</li>
        <li>The useEffect() function takes a callback function (effect) as its argument, which runs after the component
          renders.</li>
        <img src="./assets/images/useEffectExample.jpg" alt="useEffect example">
        <li>In the example, the effect changes the document title based on the value of the 'name' state.</li>
        <li>The effect runs after each render of the component.</li>
        <li>The onChange event listener triggers re-rendering of the component when the user types in the input field,
          which in turn triggers the effect.</li>
        <li>Access to the current state is available inside the effect, even though it runs after the component renders.
        </li>
        <li>React renders the component, updates the DOM, and then runs the effect after the DOM update.</li>
        <li>This process occurs for every render, including the first and last render.</li>
      </ul>
    </section>

    <section>
      <h3>Clean up Effects</h3>
      <ul>
        <li>Some effects require cleanup to avoid memory leaks and performance issues.</li>
        <li>When adding event listeners or other interactions with the DOM, it's important to remove them when no longer
          needed.</li>
        <img src="./assets/images/cleanUpEffectHook.jpg" alt="clean up effect">
        <li>To clean up an effect, return a cleanup function from the useEffect() Hook.</li>
        <li>The cleanup function is called before each re-render or unmounting of the component.</li>
        <li>By returning a cleanup function, we ensure that any resources associated with the effect are properly
          cleaned up.</li>
        <li>In the example, the cleanup function removes the event listener added in the effect by using
          document.removeEventListener().</li>
        <li>It is our responsibility to include a cleanup function when our effect code could create memory leaks or
          unnecessary performance overhead.</li>
      </ul>
    </section>

    <section>
      <h3>Control when Effects are Called</h3>
      <ul>
        <li>The useEffect() function calls its first argument (the effect) after each time a component renders.</li>
        <li>We can control when the effect is called by using the second argument, known as the dependency array.</li>
        <li>If we want the effect to be called only after the first render and not on re-renders, we pass an empty array
          [] as the dependency array.</li>
        <li>Passing an empty array [] as the dependency array ensures that the effect is called only once, when the
          component mounts.</li>
        <li>If a cleanup function is returned from the effect, it will be called when the component unmounts, regardless
          of the dependency array.</li>
        <li>The dependency array is used to specify dependencies that, when changed, will trigger the effect to be
          called again.</li>
        <li>By carefully choosing the dependencies in the array, we can control when the effect is called based on
          specific changes in our component's state or props.</li>
        <img src="./assets/images/useEffectDependencyArray.jpg" alt="effect with dependency array">
        <li>In the example, the effect displays an alert when the component mounts and the cleanup function displays an
          alert when the component unmounts.</li>
        <li>By passing an empty array as the second argument to useEffect(), we ensure that the alerts are shown only
          once, on mount and unmount.</li>
      </ul>
    </section>

    <section>
      <h3>Fetch Data</h3>
      <ul>
        <li>When fetching data from a server, it's important to control when the effect is called to avoid unnecessary
          round trips.</li>
        <li>Unnecessary fetches can impact processing, performance, data usage, and API service fees.</li>
        <li>By using the dependency array in useEffect(), we can configure exactly when the effect should be called.
        </li>
        <li>An empty dependency array [] indicates that the effect should be called only after the first render and
          never re-run.</li>
        <li>When the response is received, we can store the data in local component state using a state setter from the
          State Hook.</li>
        <li>This pattern of using the State Hook and the Effect Hook together allows components to avoid unnecessary
          data fetches after every render.</li>
        <li>An empty dependency array signals that the effect doesn't depend on anything and doesn't need to be re-run.
        </li>
        <li>A non-empty dependency array tells the Effect Hook to skip calling the effect after re-renders unless one of
          the dependencies has changed.</li>
        <img src="./assets/images/fetchData.jpg" alt="fetch data example">
        <li>In the example, the effect sets the document title based on the value of the "count" variable, and it will
          be re-run only if the value of "count" changes.</li>
      </ul>
    </section>

    <section>
      <h3>Rules of Hooks</h3>
      <ul>
        <li>Rule 1: Only call Hooks at the top level. Avoid calling hooks inside loops, conditions, or nested functions.
        </li>
        <li>Hooks should be called consistently and not conditionally based on certain conditions.</li>
        <img src="./assets/images/incorrectHookUse.jpg" alt="incorrect use of hook inside a conditional">
        <li>Instead of conditionally calling useEffect() inside an if statement, call it at the top level and put the
          condition inside the effect.</li>
        <img src="./assets/images/correctHookUse.jpg" alt="correct use of conditional with a hook">
        <li>Rule 2: Only call Hooks from React functions. Hooks can be used in function components and custom hooks.
        </li>
        <li>Custom hooks are functions that use Hooks and can be used to organize and reuse stateful logic between
          function components.</li>
      </ul>
    </section>

    <section>
      <h3>Separate Hooks for Separate Effects</h3>
      <ul>
        <li>When multiple closely related values change together, it can be useful to group them in a collection like an
          object or array.</li>
        <li>Bundling data together in a single object can add complexity to the code responsible for managing that data.
        </li>
        <li>To separate concerns and manage different data with different Hooks, it is recommended to use separate Hooks
          for separate effects.</li>
        <img src="./assets/images/nonSeperateHooks.jpg" alt="non seperated hooks">
        <li>In the example provided, the first code snippet bundles the position and menuItems data in a single object
          using one useEffect hook.</li>
        <img src="./assets/images/seperateHooks.jpg" alt="seperate hooks">
        <li>The second code snippet demonstrates a simpler approach where concerns are separated:</li>
        <li>menuItems is managed using one useEffect hook with its own state variable and update function.</li>
        <li>position is managed using a separate useEffect hook with its own state variable and update function.</li>
        <li>It may not always be obvious whether to bundle data together or separate it, but with practice, we can
          improve the organization of our code for better understanding, maintainability, reusability, and testing.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Effect Hook</h3>
      <ul>
        <li>We can import the useEffect() function from the 'react' library and call it in our function components.</li>
        <li>Effect refers to a function that we pass as the first argument of the useEffect() function. By default, the
          Effect Hook calls this effect after each render.</li>
        <li>The cleanup function is optionally returned by the effect. If the effect does anything that needs to be
          cleaned up to prevent memory leaks, then the effect returns a cleanup function, then the Effect Hook will call
          this cleanup function before calling the effect again as well as when the component is being unmounted.</li>
        <li>The dependency array is the optional second argument that the useEffect() function can be called with in
          order to prevent repeatedly calling the effect when this is not needed. This array should consist of all
          variables that the effect depends on. </li>
        <li>The Effect Hook is all about scheduling when our effect’s code gets executed. We can use the dependency
          array to configure when our effect is called in the following ways:</li>
        <li>Dependency Array: undefined, Effect called after first render & … every re-render</li>
        <li>Dependency Array: Empty array, Effect called after first render & … no re-renders</li>
        <li>Dependency Array: Non-empty array, Effect called after first render & … when any value in the dependency
          array changes</li>
        <li>Hooks gives us the flexibility to organize our code in different ways, grouping related data as well as
          separating concerns to keep code simple, error-free, reusable, and testable!</li>
      </ul>
    </section>

  </main>

</body>

</html>
